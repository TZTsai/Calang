LINE    := %SEQ < ( CMD | DEF | EXP | EMPTY ) ; >
EMPTY   := /\s*/

CMD     := CONF | DIR | DEL | LOAD | IMPORT
CONF    := config /\w+/ ( NUM | /on|off/ ) ?
DIR     := dir FIELD ?
DEL     := del %SEQ < FIELD , >  ## DELAY
LOAD    := load /[\w\.]+/ /-[tvw]/ *
IMPORT  := import /[\w\.]+/ /-[vw]/ *

DEF     := TO_DEF AT:DECO ? = EXP DOC ?  ## DELAY
TO_DEF  := ( NAME . ) * _DF
_DF     := FUNC | _VAR
FUNC    := NAME FORM
_VAR    := VARS | NAME
VARS    := %BKT < %SEQ < _VAR , > >
DOC     := /".*"/

FIELD   := NAME ATTR *
NAME    := /[\u0374-\u03FFa-zA-Z][a-zA-Z\d_]*[?]?/    ## can begin with a Greek letter
ATTR    := . / NAME:ATTR                              ## '/' forces no space in between

FORM    := PAR_LST | NAME:PAR
PAR_LST := %BKT < ( _PARS ( , _OPTS ) ? ( , _EXT ) ? |  _OPTS ( , _EXT ) ? | _EXT ? ) >
_PARS   := %SEQ < ( BIND ! FORM ~ ! ) , >             ## '!' forbids the match
_OPTS   := %SEQ < ( BIND:OPTPAR ~ ! ) , >
_EXT    := NAME:EXTPAR ~

EXP     := MAP | LET | ENV | PRT

MAP     := FORM => EXP:DELAY
LET     := ENV EXP:DELAY
ENV     := AT | %GRP < %SEQ < BIND , > > | MATCH
AT      := @ _VAL
BIND    := _DF = EXP  ## DELAY
MATCH   := FORM :: _VAL
_VAL    := APPLY:SEQ | ITEM
APPLY   := FIELD ( GEN_LST | VAL_LST )

PRT     := PRINT:H_PRINT ? ( IF_ELSE | SEQ ) PRINT:T_PRINT ?
IF_ELSE := SEQ if SEQ else EXP  ## DELAY
SEQ     := _TERM ( ( ATTR ! BOP ) ? _TERM ) *
_TERM   := LOP ? ITEM ROP ?

PRINT   := /`.*?`/
ITEM    := GROUP | WHEN | ATOM | LIST
GROUP   := %GRP < EXP >
WHEN    := when %GRP < ( ( CASE , ) + EXP ) >  ## DELAY
CASE    := EXP : EXP

ATOM    := FIELD | ATTR | SYM | ANS | NUM
SYM     := ' NAME:SYM
ANS     := /_(\d+|_*)/

NUM     := COMPLEX | BIN | HEX | REAL
COMPLEX := REAL [+-] REAL I
REAL    := /-?\d+(\.\d+)?/ ( [eE] - /-?\d+/ ) ?
BIN     := /0b[01]+/
HEX     := /0x[0-9a-fA-F]+/

LIST    := ' SYM_LST | GEN_LST | IDC_LST | VAL_LST
SYM_LST := %LST < ( UNQUOTE | _SYM_IT ) , >
UNQUOTE := ` ( LIST | NAME )  ## convert the item back to a value
_SYM_IT := SYM_LST | NAME:SYM
GEN_LST := %BKT < ( EXP ( for CONSTR ) + ) >  ## DELAY
CONSTR  := FORM in EXP ( if EXP ) ?
IDC_LST := %BKT < %SEQ < SLICE , > >
SLICE   := _SLC : _SLC ( : _SLC ) ?
_SLC    := ( SEQ | EMPTY )
VAL_LST := _DLST | %LST < EXP , >
_DLST   := %LST < SUB_LST:VAL_LST ; >
SUB_LST := %SEQ < EXP , > ?

### MACROS ###
%LST < $ITM $SEP >  := %BKT < ( %SEQ < $ITM $SEP > ? ) >
%BKT < $EXP >       := "[" - $EXP "]" -
%GRP < $EXP >       := "(" - $EXP ")" -
%SEQ < $ITM $SEP >  := $ITM ( $SEP $ITM ) *


###############################################
COMMENTS ON CALC-GRAMMAR 
The most special rules of this grammar are:
1. Mapping: '[formal] => [exp]'
   A mapping accepts a formal parameter or a (nested) list of parameters
   and transforms it into the corresponding expression. To apply a mapping,
   precedes it with a value. The value should be automatically matched to the
   [formal], bind each parameter with its corresponding value.
   Furthermore, a list is inherently a mapping in this calc. 
   As a mapping, it can be applied to a list of subscriptions. The 
   subscription at index [i] subscribes the list at depth [i]. A subscription 
   can be an integer, a list, or a slice. As a list, each of its leaf is mapped 
   to the corresponding item of the applied list.
2. Substitution: '[bindings] => [exp]'
   A substitution is the application of a mapping. It offers a more
   convenient syntax for this application. The bindings are contained in a
   group, separated by ','. Each binding is in the form of '[formal] : [val]'.
   Groups in this grammar are wrapped with '(' and ')'.
   Note that a group of bindings can exist independently in the calc, thus
   allowing a NAME or field to be bound to it. 
   For example, define 'a' as '(x: 1, y: f)'. Then 1 is substituted for 'a=>x'
   and 'f' is substituted for 'a=>y'. Moreover, 'a=>y[3]' will be replaced as
   'f[3]', an application. The expression after the dot can be more complicated,
   e.g. 'a => y[x+2] * (y: 2) => y', which will be mapped into 'f[3] * 2'.
3. Field: '[field] .[subfield]'
   In this calc, any field can be bound to a value. A NAME is a field in the
   uppermost level. If a field is initially only bound to a value and a subfield
   of it is defined, it will hold its original value as well as a group of bindings.
   In the computation, this field will still be evaluated as its initial value,
   except that its initial value is already a group of bindings, in which case
   adding subfields to it will affect the evaluated result.
   In implementation, the bindings are contained in a python dict. Initially a
   field is bound to its originally value. When subfields are added, it is turned
   into a dict, holding its defined subfields and two special subfields: '__parent__'
   and '__val__'. The user cannot access them because legal field names must not
   begins with underscores. If the original value is already bindings, then its
   '__val__' is itself.
   The global env of the calc may be considered as a meta-field, where all built-ins
   and names are defined. The 'ENV [field]' command can show the subfields of the
   field. Without the parameter, this command shows the global env.