# utils
gcd[a, b] = a if b == 0 else gcd[b, a%b]
prime?[n] = ((find_divisor[t] =
              when(t^2>n: n, n%t==0: t, find_divisor[t+1+t%2]))
             n > 1 and find_divisor[2] == n)
first[l, pred] = (rec[i] = l[i] if pred[l[i]] else rec[i+1]) rec[0]

# Groups
Group[m, o] = (
     mul = m, zero = o,
     pow[x, k] = (rec[a, b, i] = a if i==0 else
                               rec[m[a,b], b, i-1] if i%2 else
                               rec[a, m[b,b], i/2])
                rec[1, x, k]
)

CyclicGroup[g, m, o] @Group[m, o] = (
     gen = g,
     elements[] = (rec[x, l] = l if x in l else rec[m[g,x], l+[x]])
                 rec[g, []],
     order[x = 'nan] = len[elements[]] if x=='nan else
                    (rec[r, k] = k if r==zero else rec[mul[x,r], k+1])
                    rec[x, 1]
)

# Integer Modular Multiplicative Group
Zx[p] @CyclicGroup[Zx.find_gen[p], Zx.mul[p], 1] = (
     elements = [x for x in 1..p-1 if gcd[x, p] == 1],
     inverse[x] = first[elements, el => mul[x, el]==1],
     order[x = 'nan] = len[elements] if x=='nan else Zx.order[x, p]
)
Zx.order[g, p] = (G = CyclicGroup[g, Zx.mul[p], 1]) G.order[g]
Zx.mul[p] = [x, y] => x*y%p
Zx.find_gen[p] = first[list[2..p-1], x => Zx.order[x, p]==p-1]

# Finite Field
MakeGF[g, m, n] = (
     reduce[p] = when(p == []: [0],
                      p[0] == 0: reduce[p[1:]],
                      len[p] > n: ((q = poly.pad_zero[g, len[p], 0]) ...
                                   reduce[poly.sub[p, poly.scale[q, p[-1]]]]),
                      [c%m for c in p]),
     mul[p, q] = reduce[poly.mul[p, q]],
     get[] @CyclicGroup[g, mul, [1]] = (mod = m, deg = n)
)
poly = (
     scale[p, a] = p .* a,
     pad_zero[p, n, right=1] = ((k = n-len[l]) ...
          when(k<=0: l, right: l+[0]*k, [0]*k+l)),
     add[p, q] = ((n = max[len[p], len[q]]) ...
          pad_zero[p, n] .+ pad_zero[q, n]),
     sum[ps~] = [0] if ps == [] else add[ps[0], sum[ps[1:]~]],
     raise[p, k] = [0]*k + p,
     mul[p, q] = sum[raise[scale[p, c], i] for [i, c] in enum[q]],
     sub[p, q] = add[p, scale[q, -1]]
)
GF[g, m, n] = MakeGF[g, m, n].get[]


#TEST
h = Zx[7]
h.elements #(1, 2, 3, 4, 5, 6)
h.order[] #6
[[x, h.order[x]] for x in h.elements] #((1,1),(2,3),(3,6),(4,3),(5,6),(6,2))
[[x, h.inverse[x]] for x in h.elements] #((1,1),(2,4),(3,5),(4,2),(5,3),(6,6))
h.pow[4, 87]
g = Zx[24]
g.elements #(1, 5, 7, 11, 13, 17, 19, 23)
gf = GF[[1,0,2,1], 3, 3]
[gf.mod, gf.deg] #(3, 3)
gf.mul[[1, 2], [2, 0, 1, 2]]
gf.elements[]
gf = GF[[1, 1, 0, 1, 1, 0, 0, 0, 1], 2, 8]
gf.mul[[1, 1, 0, 0, 1, 0, 0, 1], [1, 0, 1]]  #(1,0,0,1,0,1,1,1)