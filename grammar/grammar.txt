LINE    := ( CMD | DEF | EXP ) HIDE ? COMMENT ? | EMPTY
EMPTY   := //

CMD     := CONF | DIR | DEL | LOAD | IMPORT
CONF    := conf /\w+/ /\d+|on|off/ ?
DIR     := dir - FIELD ?
DEL     := del %SEQ < FIELD , > 
LOAD    := load /\w+/ /-[tvp]/ *
IMPORT  := import /\w+/ /-[tvp]/ *
HIDE    := ;
COMMENT := [#] - /.*/

DEF     := PATTERN := EXP
PATTERN := FIELDS ( %GRP < NAME > | FORM ) ?
### FIELD FORM := EXP  <==>  FIELD := FORM -> EXP ###

FIELDS  := %SEQ < FIELD @ >  
FIELD   := %SEQ < NAME ( . / ) >                      ## '/' forces no space between
NAME    := /[\u0374-\u03FFa-zA-Z][a-zA-Z\d_]*[?]?/    ## can begin with a Greek letter
FORM    := %BKT < ( _PARS ? ( , _BINDS ) ? ( , EXT_PAR ) ? ) > | NAME
_PARS   := %SEQ < ( BIND ! FORM ) , >                 ## '!' forbids the next match
EXT_PAR := [*] - NAME

EXP     := MAP | LET | MATCH | VAL
### RULES for ARROW ###
##  FORM -> EXP          ==>  MAP
##  ENV  -> EXP          ==>  VAL
##  VAL  -> FORM         ==>  ENV
##  VAL  -> FORM -> EXP  ==>  ENV -> EXP  <==>  VAL -> MAP  ==>  VAL

MAP     := FORM -> EXP
LET     := ( ENV | MATCH ) -> EXP
MATCH   := VAL -> FORM
ENV     := %GRP < _BINDS >
_BINDS  := %SEQ < BIND , >
BIND    := FORM : EXP

VAL     := IF_ELSE | SEQ
IF_ELSE := SEQ if SEQ else EXP
SEQ     := ( _TERM + ( -> ! BOP ) ? ) +
## a little verbose but the arrow '->' must not be mistaken with the minus op '-'
_TERM   := ( ITEM | LOP ITEM ) ROP ? ( PRINT - ) ? 

PRINT   := " /.*?/ "
ITEM    := ENV | GROUP | WHEN | ATOM | LST
GROUP   := %GRP < EXP >
WHEN    := when %GRP < ( %SEQ < CASE , > , EXP ) >
CASE    := EXP : EXP

ATOM    := FIELD | SYM | ANS | NUM
SYM     := ' NAME
ANS     := _ /(\d+|_*)/

NUM     := COMPLEX | BIN | HEX | REAL
COMPLEX := REAL [+-] REAL I
REAL    := /-?\d+(\.\d*)?/ ( [eE] - /-?\d+/ ) ?
BIN     := /0b[01]+/
HEX     := /0x[0-9a-fA-F]+/

LST     := SYM_LST | GEN_LST | _LST | MAT_LST
SYM_LST := ' %LST < ( UNQUOTE ? NAME | SYM_LST ) , >
UNQUOTE := `
GEN_LST := %BKT < ( EXP ( [|] - CONSTR ) + ) >
CONSTR  := NAME in EXP ( and EXP ) ?
_LST    := %LST < LS_ITEM , >
MAT_LST := %LST < ROW_LST ; >
ROW_LST := %SEQ < LS_ITEM , >
LS_ITEM := SLICE | [*] ? EXP
SLICE   := _SLC : _SLC ( : _SLC ) ?
_SLC    := ( SEQ | EMPTY )

%LST < $ITM $SEP >  := %BKT < ( %SEQ < $ITM $SEP > ? ) >
%BKT < $EXP >       := "[" - $EXP "]" -
%GRP < $EXP >       := "(" - $EXP ")" -
%SEQ < $ITM $SEP >  := $ITM ( $SEP $ITM ) *


###############################################
COMMENTS ON CALC-GRAMMAR 
The most special rules of this grammar are:
1. Mapping: '[formal] -> [exp]'
   A mapping accepts a formal parameter or a (nested) list of parameters
   and transforms it into the correspnding expression. To apply a mapping,
   precedes it with a list of arguments. Lists in this grammar are wrapped
   with '[' and ']'.
   Furthermore, a list is inherently a mapping in this calc. 
   As a mapping, it can be applied to a list of subscriptions. The 
   subscription at index [i] subscribes the list at depth [i]. A subscription 
   can be an integer, a list, or a slice. As a list, each of its leaf is mapped 
   to the corresponding item of the applied list.
2. Substitution: '[bindings] -> [exp]'
   A substitution is the application of a mapping. It offers a more
   convenient syntax for this application. The bindings are contained in a
   group, separated by ','. Each binding is in the form of '[formal] : [val]'.
   Groups in this grammar are wrapped with '(' and ')'.
   Note that a group of bindings can exist independently in the calc, thus
   allowing a name or field to be bound to it. 
   For example, define 'a' as '(x: 1, y: f)'. Then 1 is substituted for 'a->x'
   and 'f' is substituted for 'a->y'. Moreover, 'a->y[3]' will be replaced as
   'f[3]', an application. The expression after the dot can be more complicated,
   e.g. 'a -> y[x+2] * (y: 2) -> y', which will be mapped into 'f[3] * 2'.
3. Field: '[field] .[subfield]'
   In this calc, any field can be bound to a value. A name is a field in the
   uppermost level. If a field is initially only bound to a value and a subfield
   of it is defined, it will hold its original value as well as a group of bindings.
   In the computation, this field will still be evaluated as its initial value,
   except that its initial value is already a group of bindings, in which case
   adding subfields to it will affect the evaluated result.
   In implementation, the bindings are contained in a python dict. Initially a
   field is bound to its originally value. When subfields are added, it is turned
   into a dict, holding its defined subfields and two special subfields: '__parent__'
   and '__val__'. The user cannot access them because legal field names must not
   begins with underscores. If the original value is already bindings, then its
   '__val__' is itself.
   The global env of the calc may be considered as a meta-field, where all built-ins
   and names are defined. The 'DIR [field]' command can show the subfields of the
   field. Without the parameter, this command shows the global env.